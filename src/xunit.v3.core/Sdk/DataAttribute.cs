using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading.Tasks;
using Xunit.Internal;
using Xunit.v3;

namespace Xunit.Sdk;

/// <summary>
/// Abstract attribute which represents a data source for a data theory.
/// Data source providers derive from this attribute and implement GetData
/// to return the data for the theory.
/// </summary>
[DataDiscoverer(typeof(DataDiscoverer))]
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public abstract class DataAttribute : Attribute
{
	static readonly Dictionary<string, List<string>> emptyTraits = new();
	static readonly MethodInfo? tupleIndexerGetter;
	static readonly MethodInfo? tupleLengthGetter;
	static readonly Type? tupleType;

	static DataAttribute()
	{
		tupleType = Type.GetType("System.Runtime.CompilerServices.ITuple");
		if (tupleType == null)
			return;

		tupleIndexerGetter = tupleType.GetProperty("Item")?.GetMethod;
		tupleLengthGetter = tupleType.GetProperty("Length")?.GetMethod;
	}

	/// <summary>
	/// Gets a flag that indicates that the data row should only be run explicitly. If the value is not set,
	/// then it inherits its explicitness from the value of <see cref="FactAttribute.Explicit"/>.
	/// </summary>
	/// <remarks>
	/// Note: any data row which returns <see cref="ITheoryDataRow"/> with a non-<c>null</c>
	/// value for <see cref="ITheoryDataRow.Explicit"/> will use the explicit value from the data row
	/// and not the explicit value from the data attribute.
	/// </remarks>
	public bool Explicit
	{
		get => ExplicitWithoutDefaultValue ?? false;
		set => ExplicitWithoutDefaultValue = value;
	}

	/// <summary>
	/// Gets the value for <see cref="Explicit"/>, except that it keeps track of whether it has been set
	/// or not, and returns <c>null</c> if it hasn't been set.
	/// </summary>
	/// <remarks>
	/// Since attribute initializers cannot accept nullable boolean values, this secondary attribute value
	/// (that cannot be externally set) is required to keep track of whether <see cref="Explicit"/> has been
	/// set by the user or not. At reflection time, we can peer into the <see cref="CustomAttributeData"/>,
	/// but once the attribute instance has been created, this is the only way to know for sure.
	/// </remarks>
	protected bool? ExplicitWithoutDefaultValue { get; set; }

	/// <summary>
	/// Marks all test cases generated by this data source as skipped. If the value is <c>null</c>, then
	/// it inherits its skip reason from the value of <see cref="FactAttribute.Skip"/>.
	/// </summary>
	/// <remarks>
	/// Note: any data row which returns <see cref="ITheoryDataRow"/> with a non-<c>null</c>
	/// value for <see cref="ITheoryDataRow.Skip"/> will use the skip reason from the data row
	/// and not the skip reason from the data attribute.
	/// </remarks>
	public string? Skip { get; set; }

	/// <summary>
	/// Gets or sets the display name for the test (replacing the default behavior, which would be to
	/// use <see cref="FactAttribute.DisplayName"/>, or falling back to the default test display name
	/// based on <see cref="TestMethodDisplay"/> and <see cref="TestMethodDisplayOptions"/> in the
	/// configuration file).
	/// </summary>
	public string? TestDisplayName { get; set; }

	/// <summary>
	/// Converts an item yielded by the data attribute to an <see cref="ITheoryDataRow"/>, for return
	/// from <see cref="GetData"/>. Items yielded will typically be <see cref="T:object[]"/>, <see cref="ITheoryDataRow"/>,
	/// or <see cref="T:System.Runtime.CompilerServices.ITuple"/>, but this override will allow derived
	/// derived attribute types to support additional data items. If the data item cannot be converted,
	/// this method will throw <see cref="ArgumentException"/>.
	/// </summary>
	/// <remarks>
	/// Any returned instance of <see cref="ITheoryDataRow"/> will be wrapped, and <see cref="ITheoryDataRow.Explicit"/>
	/// and/or <see cref="ITheoryDataRow.Skip"/> may be set with values from <see cref="ExplicitWithoutDefaultValue"/>
	/// and/or <see cref="Skip"/> if the data row did not provide overrides.
	/// </remarks>
	/// <param name="testMethod">The method that is being tested.</param>
	/// <param name="dataRow">An item yielded from the data member.</param>
	/// <returns>An <see cref="ITheoryDataRow"/> suitable for return from <see cref="GetData"/>.</returns>
	/// <exception cref="ArgumentException">Thrown when <paramref name="dataRow"/> does not point to a valid data
	/// row (must be compatible with <see cref="T:object[]"/> or <see cref="ITheoryDataRow"/>).</exception>
	protected virtual ITheoryDataRow ConvertDataRow(
		MethodInfo testMethod,
		object dataRow)
	{
		Guard.ArgumentNotNull(testMethod);
		Guard.ArgumentNotNull(dataRow);

		if (dataRow is ITheoryDataRow theoryDataRow)
			return new TheoryDataRow(theoryDataRow.GetData())
			{
				Explicit = theoryDataRow.Explicit ?? ExplicitWithoutDefaultValue,
				Skip = theoryDataRow.Skip ?? Skip,
				TestDisplayName = theoryDataRow.TestDisplayName,
				Traits = theoryDataRow.Traits ?? emptyTraits,
			};

		if (dataRow is object?[] array)
			return new TheoryDataRow(array)
			{
				Explicit = ExplicitWithoutDefaultValue,
				Skip = Skip,
			};

		if (tupleType != null && tupleIndexerGetter != null && tupleLengthGetter != null)
		{
			if (tupleType.IsAssignableFrom(dataRow.GetType()))
			{
				var countObj = tupleLengthGetter.Invoke(dataRow, null);
				if (countObj != null)
				{
					var count = (int)countObj;
					var data = new object?[count];
					for (var idx = 0; idx < count; ++idx)
						data[idx] = tupleIndexerGetter.Invoke(dataRow, new object[] { idx });

					return new TheoryDataRow(data)
					{
						Explicit = ExplicitWithoutDefaultValue,
						Skip = Skip,
					};
				}
			}
		}

		throw new ArgumentException($"Data row of type '{dataRow.GetType().SafeName()}' is not an 'object?[]', 'Xunit.ITheoryDataRow' or 'System.Runtime.CompilerServices.ITuple'", nameof(dataRow));
	}

	/// <summary>
	/// Returns the data to be used to test the theory.
	/// </summary>
	/// <remarks>
	/// If you don't use <see cref="ConvertDataRow(MethodInfo, object)"/> to convert individual data rows
	/// into <see cref="ITheoryDataRow"/> instances, then make sure you are properly populating the theory
	/// data instance (with values from <see cref="ExplicitWithoutDefaultValue"/> and <see cref="Skip"/>).
	/// </remarks>
	/// <param name="testMethod">The method that is being tested</param>
	/// <returns>One or more rows of theory data. Each invocation of the test method
	/// is represented by a single instance of <see cref="ITheoryDataRow"/>.</returns>
	public abstract ValueTask<IReadOnlyCollection<ITheoryDataRow>?> GetData(MethodInfo testMethod);
}
